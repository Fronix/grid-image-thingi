"use client";
export const drawGrid = (canvas: HTMLCanvasElement) => (images: string[]) => {
  const ctx = canvas.getContext("2d") as CanvasRenderingContext2D;

  console.log(canvas.clientHeight, canvas.clientWidth, images.length);
  // Set the canvas to a higher resolution
  const scaleFactor = window.devicePixelRatio || 1;
  const clientWidth = canvas.width;
  const clientHeight = canvas.height;
  canvas.width = clientWidth * scaleFactor;
  canvas.height = clientHeight * scaleFactor;
  ctx.scale(scaleFactor, scaleFactor);

  const numColumns = Math.ceil(Math.sqrt(images.length));
  const numRows = Math.ceil(images.length / numColumns);
  const maxImageWidth = clientWidth / numColumns;
  const maxImageHeight = clientHeight / numRows;

  images.forEach((src, index) => {
    const img = new Image();
    img.src = src;

    img.onload = () => {
      const aspectRatio = img.width / img.height;
      let drawWidth, drawHeight;

      if (aspectRatio > 1) {
        // Landscape
        drawWidth = maxImageWidth;
        drawHeight = drawWidth / aspectRatio;
      } else {
        // Portrait or square
        drawHeight = maxImageHeight;
        drawWidth = drawHeight * aspectRatio;
      }

      // Ensure the image fits within the grid cell dimensions
      if (drawWidth > maxImageWidth) {
        drawWidth = maxImageWidth;
        drawHeight = drawWidth / aspectRatio;
      }
      if (drawHeight > maxImageHeight) {
        drawHeight = maxImageHeight;
        drawWidth = drawHeight * aspectRatio;
      }

      const x =
        (index % numColumns) * maxImageWidth + (maxImageWidth - drawWidth) / 2;
      const y =
        Math.floor(index / numColumns) * maxImageHeight +
        (maxImageHeight - drawHeight) / 2;

      // Draw the image
      ctx.drawImage(img, x, y, drawWidth, drawHeight);

      // Draw the number on top of the image
      const textX = x + drawWidth / 2;
      const textY = y + 20; // Slight padding from the top of the image

      // Add semi-transparent background behind the text for readability
      const textBackgroundHeight = 20;
      ctx.fillStyle = "rgba(0, 0, 0, 1)";
      ctx.fillRect(
        textX - 10,
        textY - textBackgroundHeight / 2,
        20,
        textBackgroundHeight
      );

      ctx.font = "32px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "#fff";
      ctx.fillText((index + 1).toString(), textX, textY);
    };

    img.onerror = () => {
      console.error(`Failed to load image: ${src}`);
    };
  });

  // Add watermark
  const watermarkText = "Generated by grid-image-thingi.fronix.se";
  ctx.font = "16px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";
  ctx.fillStyle = "rgba(255, 255, 255, 1)"; // Semi-transparent white

  //ensure the watermark is always on top of the images
  ctx.globalCompositeOperation = "source-over";
  ctx.fillText(watermarkText, clientWidth / 2, clientHeight - 10);
};

export const drawXOverImage = (
  canvas: HTMLCanvasElement,
  imageIndex: number,
  numColumns: number,
  numRows: number,
  maxImageWidth: number,
  maxImageHeight: number
) => {
  const ctx = canvas.getContext("2d") as CanvasRenderingContext2D;

  const col = imageIndex % numColumns;
  const row = Math.floor(imageIndex / numColumns);
  const x = col * maxImageWidth;
  const y = row * maxImageHeight;

  ctx.strokeStyle = "red";
  ctx.lineWidth = 5;

  // Draw a big "X" over the image
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x + maxImageWidth, y + maxImageHeight);
  ctx.moveTo(x + maxImageWidth, y);
  ctx.lineTo(x, y + maxImageHeight);
  ctx.stroke();
};
